%% ======================================================
%  TELECOM PROJECT - TASK II
%  Add Noise and Test Robustness
%  Author: Nom Prénom
%  ======================================================

clc; clear; close all;

%% 1. Paramètres
N = 1e5;                  % Nombre de bits
M = 4;                    % Ordre de modulation (QPSK)
k = log2(M);              % Bits par symbole
Rs = 1e5;                 % Débit symbole (100 ksym/s)
Fs = Rs * 8;              % Fréquence d’échantillonnage (8 échantillons/symbole)
sps = Fs / Rs;            % Échantillons par symbole
EbN0_dB = 10;             % SNR du canal (modifiable)
add_impulsive_noise = true;
add_fading = true;

%% 2. Source binaire
bits = randi([0 1], N, 1);
disp('Source binaire générée.');

%% 3. Modulation QPSK directe
symbols = pskmod(bits, M, pi/M, 'InputType', 'bit');  
disp('Modulation QPSK effectuée.');

%% 4. Filtrage Raised Cosine à l’émission
rolloff = 0.25; span = 10; 
rrcFilter = rcosdesign(rolloff, span, sps, 'sqrt');
tx_signal = upfirdn(symbols, rrcFilter, sps, 1);
disp('Filtrage Raised Cosine appliqué (émission).');

%% 5. Canal avec bruit
snr = EbN0_dB + 10*log10(k);  % conversion Eb/N0 -> SNR symbolique
rx_signal = awgn(tx_signal, snr, 'measured');  % bruit blanc gaussien additif
disp(['Canal AWGN appliqué avec Eb/N0 = ' num2str(EbN0_dB) ' dB.']);

% --- Optionnel : bruit impulsif ---
if add_impulsive_noise
    num_impulses = 100;
    idx = randperm(length(rx_signal), num_impulses);
    rx_signal(idx) = rx_signal(idx) + 5*randn(num_impulses,1);
    disp('Bruit impulsif ajouté.');
end

% --- Optionnel : fading de Rayleigh ---
if add_fading
    h = (randn(size(rx_signal)) + 1j*randn(size(rx_signal))) / sqrt(2);
    rx_signal = rx_signal .* h;
    rx_signal = rx_signal ./ h; % égalisation parfaite (pour analyse)
    disp('Canal de Rayleigh simulé.');
end

%% 6. Filtrage Raised Cosine à la réception (apparié)
rx_filtered = upfirdn(rx_signal, rrcFilter, 1, sps);
delay = span; % délai de groupe (en symboles)
rx_sync = rx_filtered(delay+1 : delay+length(symbols)); 
disp('Filtrage apparié et synchronisation appliqués.');

%% 7. Démodulation QPSK
bits_rx = pskdemod(rx_sync, M, pi/M, 'OutputType', 'bit');

%% 8. Vérification BER
L = min(length(bits), length(bits_rx));
BER = mean(bits(1:L) ~= bits_rx(1:L));
disp(['BER (avec bruit) = ' num2str(BER)]);

%% 9. Visualisation
t = (0:length(tx_signal)-1)/Fs;

figure('Name','Analyse du signal QPSK avec bruit', 'Color', 'w');

% Signal temporel
subplot(2,2,1);
plot(t(1:1000), real(rx_signal(1:1000)), 'LineWidth', 1.2);
title('Signal temporel bruité (partie réelle)');
xlabel('Temps (s)');
ylabel('Amplitude');
grid on;

% Spectre
subplot(2,2,2);
pwelch(rx_signal, [], [], [], Fs, 'centered');
title('Spectre du signal reçu (avec bruit)');

% Constellation émise
subplot(2,2,3);
plot(real(symbols), imag(symbols), 'o', 'MarkerSize', 5, ...
    'MarkerFaceColor', [0.2 0.5 1], 'MarkerEdgeColor', 'k');
title('Constellation émise (baseband)');
xlabel('In-Phase'); ylabel('Quadrature');
axis equal; grid on;


figure('Name','Analyse du signal QPSK avec bruit', 'Color', 'w');

% Constellation reçue
subplot(2,2,4);
plot(real(rx_sync), imag(rx_sync), 'o', 'MarkerSize', 5, ...
    'MarkerFaceColor', [1 0.2 0.2], 'MarkerEdgeColor', 'k');
title('Constellation reçue (avec bruit)');
xlabel('In-Phase'); ylabel('Quadrature');
axis equal; grid on;

disp('Simulation complète avec bruit terminée.');
